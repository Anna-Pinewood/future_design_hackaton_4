# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-rgLFlW0Du-NzxAIOe_Hg8HZmuhIGTwQ
"""

import datetime
import random
import warnings
from collections import namedtuple

import pandas as pd

import process

warnings.filterwarnings('ignore')


def parse_data(data):
    if data is None:
        from google.colab import drive
        drive.mount('/content/drive')
        path = "/content/drive/MyDrive/data/df2_h.csv"
        df = pd.read_csv(path, parse_dates=[0, 1, 2])
    else:
        df = data
        df = df[['date', 'begin', 'end', 'isprod']]
        df['date'] = pd.to_datetime(df.date)
    return df


def fill_missed_slots(data):
    first = data.begin.shift(periods=1) - data.end > datetime.timedelta(0)
    df_1 = data.loc[first]
    k = pd.DataFrame(columns=['date', 'begin', 'end', 'isprod'])
    for i, row in df_1.iterrows():
        tmp = [data.loc[i - 1].date, row.end, data.loc[i - 1].begin, 2]
        k.loc[len(k)] = tmp
    data = pd.concat([data, k])
    data = data.sort_values(by=['begin'])
    return data


def delete_wrong_sessions(data):
    return data.loc[data.begin != data.end]


def round_slots(data, time_round="5min"):
    # NOTE: add flexible columns
    data['begin'] = data['begin'].map(lambda x: x.round(freq=time_round))
    data['end'] = data['end'].map(lambda x: x.round(freq=time_round))
    return data


def split_slots(data, time_freq='5min', time_round="5min"):
    data = round_slots(data, time_round)
    data = delete_wrong_sessions(data)
    # разделение на интервалы
    data['slot'] = data[['begin', 'end']].agg(lambda x: pd.date_range(start=x[0], end=x[1], freq=time_freq), axis=1)
    # соединение двух последующих концов в интервалы
    data['slot'] = data['slot'].map(lambda x: list(zip(x[:-1:], x[1::])))
    # разделение на отдельные строки
    data = data.explode('slot', ignore_index=True)
    # data = data.drop(columns=['begin', 'end'])
    data = data.dropna()
    return data


def prepared_data(data=None):
    data = parse_data(data)
    data = fill_missed_slots(data)
    data = split_slots(data)
    return data


def filter_rows(data, activity_type):
    data['isprod_count'] = data['isprod'].apply(lambda x: (x == activity_type)) * data['slot']
    data = data.groupby(['week', 'simple_slot'], as_index=False).agg({'isprod_count': 'sum'})
    data['isprod'] = activity_type
    return data


def group_by_week_slot(data, activity_type):
    data = add_week_simple_slot(data)
    data = data.groupby([data['week'], data['simple_slot'], data['isprod']], as_index=False).agg({'slot': 'count'})
    data = filter_rows(data, activity_type)
    # group_mean = df_group_mean.needed_range.mean()
    return data


def add_week_simple_slot(data):
    # isocalendar - (year, week, weekday)
    # NOTE: add flexibility
    data['week'] = data['date'].apply(lambda x: x.isocalendar()[:2])
    data['simple_slot'] = data['slot'].apply(lambda x: ((x[0].hour, x[0].minute), (x[1].hour, x[1].minute)))

    return data


def union_to_hour(data):
    data['simple_slot_hour'] = data['simple_slot'].apply(lambda slot: (slot[0][0], slot[0][0] + 1))
    return data


def get_weighted_product(data):
    # NOTE: needed refactor and optimize
    df_for_mean = data.groupby('simple_slot_hour', as_index=False).agg({'isprod_count': lambda x: list(x)})
    df_for_mean['weights'] = df_for_mean['isprod_count'].apply(lambda x: pd.DataFrame(x).ewm(com=0.5).mean())
    # NOTE: tolist???
    df_for_mean['weights'] = df_for_mean['weights'].apply(lambda x: x[0].tolist())
    products = []
    # return df_for_mean
    for index, row in df_for_mean.iterrows():
        list1 = row['isprod_count']
        list2 = row['weights']
        p = sum([a * b for a, b in zip(list1, list2)]) / len(list1)
        products.append(p)
    df_for_mean['score'] = products
    return df_for_mean[['simple_slot_hour', 'score']]


def get_score(data, activity_type):
    data = group_by_week_slot(data, activity_type)
    data = union_to_hour(data)
    # NOTE: need think about agg function, bad function???
    # NOTE: add flexibility
    data = data.groupby(['week', 'simple_slot_hour'], as_index=False).agg({'isprod_count': 'mean'})
    data = get_weighted_product(data)
    return data['score']


def split_weekdays(data):
    df_weekend = data[data.date.dt.dayofweek >= 5]
    df_weekday = data[data.date.dt.dayofweek < 5]
    return df_weekday, df_weekend


def x_str(res):
    return '{}:00, {}:00'.format(*res)


def prepared_result(res, name):
    return [x_str((i, i + 1)) for i in range(0, 24)], list(res.apply(lambda x: round(x, 3))), name


def run(data=None, answers=None, activity_type=1):
    Result = namedtuple('Plot', 'X Y name')
    if not data is None:
        data = prepared_data(data)
        df_weekday, df_weekend = split_weekdays(data)
        result1 = Result(
            *prepared_result(get_score(df_weekday, activity_type=activity_type), "Продуктивные часы в будние дни"))
        result2 = Result(
            *prepared_result(get_score(df_weekend, activity_type=activity_type), "Продуктивные часы в выходные дни"))
    else:
        fake_score = pd.Series(random.randint(0, 4) for i in range(24))
        result1 = Result(*prepared_result(fake_score, "Продуктивные часы в будние дни"))
        result2 = Result(*prepared_result(fake_score, "Продуктивные часы в выходные дни"))
    return result1, result2


"""Запуск run()"""

# data_init = pd.read_csv('../data/report_initial.csv')
#
# a = process.DataStorage(data=data_init)
#
# r = run(a.data_schedule)